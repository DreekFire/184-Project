<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  .image-row {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            margin-bottom: 40px;
        }

  .image-row-centered {
      display: flex;
      flex-wrap: nowrap;
      overflow-x: auto;
      margin-bottom: 20px;
      justify-content: center;
  }

  .image {
      flex: 0 0 calc(50% - 20px);
      margin-top: 10px;
      margin-right: 20px;
      margin-left: 20px;
      margin-bottom: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
  }

  .image img {
      max-width: 100%;
      height: auto;
      margin-top: 20px;
      border: 6px solid #535353; /* Add a border to make it clear it's an image */
  }

  .image h3 {
      font-size: 18px;
      margin-top: 10px;
      margin-bottom: 0px;
  }

  .image h4 {
      font-size: 16px;
      margin-top: 10px;
      margin-bottom: 0px;
      text-align: center;
  }

  .image p {
      font-size: 14px;
  }

  .gif-image {
      flex: 0 0 calc(50% - 20px);
      margin-top: 10px;
      margin-right: 20px;
      margin-left: 20px;
      margin-bottom: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
  }

  .gif-image img {
      width: 100%;
      height: auto;
      margin-top: 20px;
      border: 6px solid #535353; /* Add a border to make it clear it's an image */
      border-radius: 4px; /* Optional: Rounded corners for aesthetics */
  }

  .gif-image h3 {
      font-size: 18px;
      margin-top: 10px;
      margin-bottom: 0px;
  }

  .gif-image p {
      font-size: 14px;
      text-align: center;
  }
</style>
<title>CS 184: Strandbeest Simulation</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Final Project Report: Strandbeest Simulation</h1>
<h2 align="middle">Derek Guo, Marcus Cheung, Pranav Kolluri, Rohan Agrawal</h2>

<br><br>

<div>

<h2 align="middle">Abstract</h2>
<p>
  We created a simulation of a <a href="https://www.strandbeest.com/">strandbeest</a> walking along a beach. We primarily focused on simulating the physical joints of the strandbeest, rigging of our model, and the visual rendering of the sand and sky.
</p>

<h2 align="middle">Technical Approach</h2>
<h3>Physics Simulation</h3>
<p>asldkmfalsdkmfalksmdflkamsldfkm</p>

<h3>Rigging Body Geometry</h3>
<p>To give the strandbeest a body, we build 3D geometry over the wireframe of pointmasses and structural springs as spheres and cylinders respectively. Firstly, we defined these two geometries.
    For spheres we adapted what existed in homework 4, turning off collision logic as to not interfere with the underlying point mass representation.
    On each timestep iterate through our point masses, editing their corresponding sphere's position coordinates to match. We defined cylinders with a given central point, radius, height, and axis vector representing its orientation.
    Then to render them we iterate through our list of structural springs, computing center point, height, and axis from the spring's end pointmasses. Computing center and height were trivial using midpoint and distance formula.
    To compute the axis we employed Rodrigues' rotation formula to transform the base axis of (0, 1, 0) to our desired orientation by deriving the rotation matrix.
    By composing a scaling transform with height and radius, the derived rotation matrix, and translation according to center point, in that order, we compute a 3D homogenous matrix to transform the unit cylinder for rendering.
</p>
<h3>Terrain</h3>
<p>Our terrain has two primary components: the actual rendered mesh and the shader. The mesh system is composed of a wrapper and main mesh method, in a similar high-level architecture to the sphere. 
  The mesh generation begins by loading a grayscale heightmap image of the desired terrain. If loading fails, a flat plane is generated.
  The mesh dimensions are derived from the image dimensions and the desired scale. The mesh is then generated by iterating through each pixel in the image and creating a vertex at the corresponding position in the mesh.
  Texture coordinates, positions, normals, and tangents are generated, like sphere_drawing in the base hw4 codebase, but the actual process of generating these is significantly more convoluted due to the nature of using an actual mesh instead of a sphere.
  Face normals are calculated by considering the vertices of adjacent triangles, and then vertex normals are computed by accumulating face normals. Tangents are computed using UV mapping and the method of finite differences to approximate the derivative of the heightmap.
  A collision method is implemented to allow for the strandbeest to interact with the terrain. 
  The particularly tricky part of this is unlike the sphere or plane, the terrain is not mathematically defined, so we have to identify teh closest vertices to the strandbeest's feet and calculate the normal of the terrain at that point.
  This is done by calculating the relative position of the points, using the terrain dimensions as our reference frame. From this, we can use this position as coordinates to index into our array of vertices.
  We can extract the 3 vertices the collision point is between and then compute the offset from the plane to the collision point. If the offset is within a certain threshold, we can consider the strandbeest to be on the terrain.
  We apply an offset to the strandbeest's position to ensure it is above the terrain and not clipping through it. This collision method also works nicely with the cloth, which is how we did our initial testing.
  <br/>
  <br/>
  The shader is quite a bit more complicated than the base phong shader from hw4. We intended to try to replicate the sand from games such as Journey, Battlefield 2042, and others. 
  The core hallmarks of these were larger scale perturbations in the sand (ripples) as well as the characteristic shimmer that sand has in the sun. 
  It features bump mapping to simulate surface irregularities and the ripples.
  In addition, Perlin noise is utilized to generate further perturbations in the sand akin to ripples.
  Sparkles are generated by perturbing normals based on a noise function, with a lot of work put in to attempt to minimize moire patterns.
  <br/>
  <br/>

  A fair few challenges were encountered in getting the terrain functional. Scaling the mesh was less than trivial as it created havoc with the collision detection and the vertices.
  However, an even bigger challenge was the shader. The shader was a massive undertaking, with a lot of time spent on it. The iteration the we have now is the 5th or 6th iteration of the shader, with the previous ones being scrapped due to various issues.
  In particular, we ran into issues with the sparkles causing obscene amounts of moire patterns and other undesirable artifacts. This required a lot of trial and error with various noise functions with different parameters.
  The ripples also proved to be a massive challenge, particularly with trying to get small scale ripples to work. 
  This is something that we still want to improve on as while we're happy with the large scale perturbations, the small scale ripples are very hard to see, despite having gone through a lot of iterations (at least a week's worth of work).
  We also had to drop our stretch plan of adding in "footsteps" into the shader, due in part to technical limitations imposed by the fairly narrow scope of the hw4 codebase. 
  In particular, we struggled to both accurately keep track of steps in a manner that would be performant with the fragment shader, which must be able to efficiently identify if a step has been taken on a given pixel.
  A preliminary version of this was implemented (multiple times), but we were never abler to get it to function with enough performance. Engines like unity and unreal have much more sophisticated systems for this, but we were unable to replicate this in our shader.
  <br/>
  <br/>
  We are, all in all, quite happy with the shader. It's not perfect, but it's a good start and we're proud of what we've accomplished. We're particularly happy with the large scale perturbations and the shimmer, which we feel are quite close to what we were aiming for.
  Had we had the additional scope to add self-shadowing, we think the terrain would be rather convincing.

</p>

<h3>Sky/Atmospherics</h3>
<p>We generated a sky using a shader projected onto a Cubemap. We for the blue sky we created a gradient between two shades of blue to 
    render a realistic sky, for the sun we rendered a circle at a point in world space, then displayed it according to the norm between the camera position and the suns position, then checking the dot product between the camera's position and the suns position to determine if the sun is visible.
    We generated clouds using a Perlin noise function to generate a 2D texture, then used a Fractal Brownian Motion function to combine layers of noise to create a cloud texture. We then calculated the direction of the ray and the distance and generated a color based on these.
</p>
<h2 align="middle">Results</h2>
<img width='150px' src="https://media.istockphoto.com/id/1409329028/vector/no-picture-available-placeholder-thumbnail-icon-illustration-design.jpg?s=612x612&w=0&k=20&c=_zOuJu755g2eEUioiOUdz_mHKJQJn-tDgIAhQzyeKUQ="></img>
<img width='150px' src="https://media.istockphoto.com/id/1409329028/vector/no-picture-available-placeholder-thumbnail-icon-illustration-design.jpg?s=612x612&w=0&k=20&c=_zOuJu755g2eEUioiOUdz_mHKJQJn-tDgIAhQzyeKUQ="></img>
<img width='150px' src="https://media.istockphoto.com/id/1409329028/vector/no-picture-available-placeholder-thumbnail-icon-illustration-design.jpg?s=612x612&w=0&k=20&c=_zOuJu755g2eEUioiOUdz_mHKJQJn-tDgIAhQzyeKUQ="></img>
<img width='150px' src="https://media.istockphoto.com/id/1409329028/vector/no-picture-available-placeholder-thumbnail-icon-illustration-design.jpg?s=612x612&w=0&k=20&c=_zOuJu755g2eEUioiOUdz_mHKJQJn-tDgIAhQzyeKUQ="></img>
<img width='150px' src="https://media.istockphoto.com/id/1409329028/vector/no-picture-available-placeholder-thumbnail-icon-illustration-design.jpg?s=612x612&w=0&k=20&c=_zOuJu755g2eEUioiOUdz_mHKJQJn-tDgIAhQzyeKUQ="></img>

<h2 align="middle">References</h2>
1. <a href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula">Rodrigues' Rotation Formula</a><br>
2. <a href="https://en.wikipedia.org/wiki/Perlin_noise">Perlin Noise</a><br>
3. <a href="https://www.alanzucconi.com/2019/10/08/journey-sand-shader-1/">Journey Sand Shader</a><br>

<h2 align="middle">Individual Contributions</h2>
<h3>Marcus</h3>
<p>Implemented the rigging of the strandbeest wireframe with 3D geometry and homogenous transformation algorithm to correctly build the cylinder according to given placement coordinate, height, radius, and axis params.</p>
<h3>Derek</h3>
<p>asldkmfalsdkmfalksmdflkamsldfkm</p>
<h3>Pranav</h3>
<p>Implemented the terrain mesh builder as well as the accompanying shader. Also contributed to the final sky shader (and had created quite a few previous versions that were scrapped).</p>
<h3>Rohan</h3>
<p>asldkmfalsdkmfalksmdflkamsldfkm</p>
</body>
</html>
